
# Trainining with only sampling methods
from pyDOE2 import lhs, fullfact, bbdesign
import sobol
import numpy as np
from sklearn import svm
from auxil.auxilfunc import test, check_class

class Sampling_based_SVM():
    def __init__(self, X_initial, max_itr, report_frq, iteration, sampling_method, 
                accuracy_method= 'F1', case = 'benchmark', svm_random_state = None, 
                **kwargs):
        ''' 
        Train SVM with data generated by sampling determined by method 
        These data are added to initial samples (X_initial) 

        #####################################################
        INPUT: 

        X_initial : initial training data 

        max_itr : maximum number of samples

        report_frq : report frequency for prediction accuracy score

        iteration : number of iterations to calculate the mean/variance of svm accuracy score

        sampling_method: {'lhs' , 'random', 'ff', 'bb', 'sobol'}

        accuracy_method: {'F1', 'MCC', 'Simple'}

        case: {'benchmark', 'simulation'}

        svm_random_state : random number for svm optimizer

        **kwargs: {condition: only for benchmark function, feasibility constraint should be given here} 

        #####################################################
        OUTPUT:

        self.score_list : svm accuracy score list

        '''
        self.X_initial = X_initial
        self.max_itr = max_itr
        self.report_frq = report_frq
        self.iteration = iteration
        self.sampling_method = sampling_method
        self.accuracy_method = accuracy_method
        self.svm_random_state = svm_random_state
        self.case = case

        self.score_list = []
        
        if case == 'benchmark': 
            if kwargs == None:
                raise ValueError('For benchmark case, function and feasibility condition should be set')
            else:                
                self.condition = kwargs['condition']

    def train(self):
        '''
        train svm using samples collected either randomly or using LHS
        '''
        X_initial = self.X_initial
        dim = X_initial.shape[1]
        report_frq = self.report_frq

        for _num_iter in np.arange(0, self.max_itr + report_frq, report_frq):
            _score_lst = []
            for itr in range(self.iteration):
                if _num_iter == 0:
                    X = X_initial.copy()

                else: 
                    # if LHS is used
                    if self.sampling_method == 'lhs':
                        X_sample = lhs(dim, samples= _num_iter)
                    # if random sampling is used
                    elif self.sampling_method == 'random':
                        X_sample = np.random.random([_num_iter, dim])
                    elif self.sampling_method == 'ff':
                        num_levels = int(_num_iter**(1/dim))
                        X_sample = fullfact([num_levels for i in range(dim)]) / (num_levels - 1)
                    elif self.sampling_method == 'sobol':
                        X_sample = sobol.sample(dimension = dim, n_points = _num_iter)
                    elif self.sampling_method == 'bb':
                        X = bbdesign(dim)
                        X[X == 0.] = 0.5   # to change -1, 0, 1 to 0, 0.5, 1
                        X[X == -1.] = 0.   # to change -1, 0, 1 to 0, 0.5, 1
                    # something else is specified
                    else:
                        raise NotImplementedError('There is no such method')


                    X = np.vstack([X_initial, X_sample])

                # check class of data points
                y = []
                if self.case == 'benchmark':
                    y = check_class(X, self.case, condition =  self.condition)
                else:
                    y = check_class(X, self.case)
                        
                # Initial setting
                svm_classifier = svm.SVC(kernel='rbf', C = 10000, random_state = self.svm_random_state)

                # Fit the data
                svm_classifier.fit(X,y)

                # Test
                score = test(1000, dim, svm_classifier, check_class, case = self.case, method = self.accuracy_method, condition = self.condition)
                _score_lst.append(score)
                
            self.score_list.append(_score_lst)
        